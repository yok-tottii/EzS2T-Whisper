<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EzS2T-Whisper 設定</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f7;
            color: #1d1d1f;
            line-height: 1.6;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        h1 {
            font-size: 32px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #6e6e73;
            margin-bottom: 40px;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .card h2 {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-weight: 500;
            margin-bottom: 8px;
        }

        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 14px;
        }

        button {
            background: #0071e3;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #0077ed;
        }

        .status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .status.granted {
            background: #d8f5e3;
            color: #0a7d3e;
        }

        .status.denied {
            background: #ffe5e5;
            color: #d70015;
        }

        .footer {
            text-align: center;
            margin-top: 40px;
            color: #6e6e73;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>EzS2T-Whisper 設定</h1>
        <p class="subtitle">音声文字起こしアプリケーションの設定</p>

        <div class="card">
            <h2>システム権限</h2>
            <div class="form-group">
                <label>マイク</label>
                <span class="status granted" id="mic-status">✓ 許可済み</span>
            </div>
            <div class="form-group">
                <label>アクセシビリティ</label>
                <span class="status granted" id="accessibility-status">✓ 許可済み</span>
            </div>
        </div>

        <div class="card">
            <h2>ホットキー</h2>
            <div class="form-group">
                <label for="hotkey-display">録音開始キー</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" id="hotkey-display" value="⌃⌥Space" readonly style="flex: 1;">
                    <button type="button" onclick="openHotkeyEditor()">変更...</button>
                </div>
                <div id="hotkey-conflict" style="margin-top: 8px; font-size: 12px; color: #d70015; display: none;"></div>
            </div>
            <div class="form-group">
                <label for="record-mode">録音モード</label>
                <select id="record-mode">
                    <option value="press-to-hold">押下中録音</option>
                    <option value="toggle">トグル切替</option>
                </select>
            </div>
        </div>

        <!-- ホットキー編集モーダル -->
        <div id="hotkey-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
            <div style="background: white; padding: 30px; border-radius: 12px; max-width: 500px; width: 90%;">
                <h3>ホットキー設定</h3>
                <p style="color: #6e6e73; font-size: 14px; margin-bottom: 20px;">
                    入力欄をクリックして、設定したいキーの組み合わせを押してください
                </p>

                <div style="margin-bottom: 20px;">
                    <input type="text" id="hotkey-input" placeholder="キーを押してください..." readonly
                           style="width: 100%; padding: 15px; font-size: 18px; text-align: center; cursor: pointer;"
                           onclick="captureHotkey()">
                </div>

                <div id="hotkey-modal-conflict" style="margin-bottom: 15px; padding: 10px; background: #ffe5e5; border-radius: 8px; display: none;">
                    <strong>⚠️ 競合検出:</strong> <span id="conflict-apps"></span>
                </div>

                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeHotkeyEditor()" style="background: #6e6e73;">キャンセル</button>
                    <button onclick="saveHotkey()" id="save-hotkey-btn">保存</button>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>音声認識</h2>
            <div class="form-group">
                <label for="model-path">モデルファイル</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" id="model-path" placeholder="モデルファイルのパスを選択または入力してください" style="flex: 1;">
                    <button type="button" onclick="browseModelFile()" style="padding: 10px 20px;">参照...</button>
                </div>
                <div id="model-info" style="margin-top: 8px; font-size: 12px; color: #6e6e73;"></div>
                <div id="model-error" style="margin-top: 8px; font-size: 12px; color: #d70015; display: none;"></div>
            </div>
            <div class="form-group">
                <label for="language">言語</label>
                <select id="language">
                    <option value="ja">日本語</option>
                    <option value="en">English</option>
                </select>
            </div>
        </div>

        <div class="card">
            <h2>マイク設定</h2>
            <div class="form-group">
                <label for="audio-device">入力デバイス</label>
                <select id="audio-device">
                    <option value="0">システムデフォルト</option>
                </select>
            </div>
        </div>

        <button onclick="saveSettings()">設定を保存</button>

        <div class="footer">
            EzS2T-Whisper v0.3.0 | オープンソース (MIT License)
        </div>
    </div>

    <script>
        // API base URL
        const API_BASE = '';

        // Load settings from server
        async function loadSettings() {
            try {
                const response = await fetch(`${API_BASE}/api/settings`);
                if (!response.ok) {
                    throw new Error('Failed to load settings');
                }
                const config = await response.json();

                // Populate form fields
                document.getElementById('record-mode').value = config.recording_mode || 'press-to-hold';
                document.getElementById('language').value = config.language || 'ja';
                document.getElementById('model-path').value = config.model_path || '';

                // Display hotkey
                if (config.hotkey) {
                    document.getElementById('hotkey-display').value = formatHotkeyDisplay(config.hotkey);
                }

                // Validate model path if present
                if (config.model_path) {
                    validateModelPath(config.model_path);
                }
            } catch (error) {
                console.error('Failed to load settings:', error);
            }
        }

        // Browse for model file
        async function browseModelFile() {
            try {
                const response = await fetch(`${API_BASE}/api/models/browse`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to open file browser');
                }

                const result = await response.json();

                if (result.cancelled) {
                    return; // User cancelled
                }

                if (result.path) {
                    document.getElementById('model-path').value = result.path;

                    // Show model info
                    const infoDiv = document.getElementById('model-info');
                    infoDiv.textContent = `${result.name} (${result.size})`;
                    infoDiv.style.display = 'block';

                    // Hide error
                    document.getElementById('model-error').style.display = 'none';
                }
            } catch (error) {
                console.error('Failed to browse file:', error);
                const errorDiv = document.getElementById('model-error');
                errorDiv.textContent = 'ファイル選択ダイアログを開けませんでした: ' + error.message;
                errorDiv.style.display = 'block';
            }
        }

        // Validate model path
        async function validateModelPath(path) {
            if (!path) {
                document.getElementById('model-info').style.display = 'none';
                document.getElementById('model-error').style.display = 'none';
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/api/models/validate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ path })
                });

                if (!response.ok) {
                    throw new Error('Failed to validate model path');
                }

                const result = await response.json();
                const infoDiv = document.getElementById('model-info');
                const errorDiv = document.getElementById('model-error');

                if (result.valid) {
                    infoDiv.textContent = `✓ ${result.name} (${result.size})`;
                    infoDiv.style.display = 'block';
                    infoDiv.style.color = '#0a7d3e';
                    errorDiv.style.display = 'none';
                } else {
                    infoDiv.style.display = 'none';
                    errorDiv.textContent = '✗ ' + result.message;
                    errorDiv.style.display = 'block';
                }
            } catch (error) {
                console.error('Failed to validate model path:', error);
                const errorDiv = document.getElementById('model-error');
                errorDiv.textContent = 'モデルファイルの検証に失敗しました';
                errorDiv.style.display = 'block';
            }
        }

        // Save settings
        async function saveSettings() {
            const modelPath = document.getElementById('model-path').value;
            const recordMode = document.getElementById('record-mode').value;
            const language = document.getElementById('language').value;

            // Validate model path before saving
            if (!modelPath) {
                alert('モデルファイルを選択してください');
                return;
            }

            try {
                // Validate first
                const validateResponse = await fetch(`${API_BASE}/api/models/validate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ path: modelPath })
                });

                const validateResult = await validateResponse.json();
                if (!validateResult.valid) {
                    alert('無効なモデルファイルです: ' + validateResult.message);
                    return;
                }

                // Save settings
                const response = await fetch(`${API_BASE}/api/settings`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model_path: modelPath,
                        recording_mode: recordMode,
                        language: language
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to save settings');
                }

                alert('設定を保存しました。変更を適用するには、アプリケーションを再起動してください。');
            } catch (error) {
                console.error('Failed to save settings:', error);
                alert('設定の保存に失敗しました: ' + error.message);
            }
        }

        // Hotkey management
        let capturedHotkey = {
            ctrl: false,
            shift: false,
            alt: false,
            cmd: false,
            key: ''
        };

        // Open hotkey editor modal
        function openHotkeyEditor() {
            document.getElementById('hotkey-modal').style.display = 'flex';
            document.getElementById('hotkey-input').value = '';
            document.getElementById('hotkey-modal-conflict').style.display = 'none';
            capturedHotkey = { ctrl: false, shift: false, alt: false, cmd: false, key: '' };
        }

        // Close hotkey editor modal
        function closeHotkeyEditor() {
            document.getElementById('hotkey-modal').style.display = 'none';
        }

        // Capture hotkey input
        function captureHotkey() {
            const input = document.getElementById('hotkey-input');
            input.focus();
            input.value = 'キーを押してください...';

            function handleKeyDown(e) {
                e.preventDefault();

                // Record modifier keys
                capturedHotkey.ctrl = e.ctrlKey;
                capturedHotkey.shift = e.shiftKey;
                capturedHotkey.alt = e.altKey;
                capturedHotkey.cmd = e.metaKey;

                // Record regular key
                if (e.key && !['Control', 'Shift', 'Alt', 'Meta'].includes(e.key)) {
                    // Convert key name
                    if (e.key === ' ') {
                        capturedHotkey.key = 'Space';
                    } else if (e.key === 'Enter') {
                        capturedHotkey.key = 'Return';
                    } else if (e.key === 'Esc' || e.key === 'Escape') {
                        capturedHotkey.key = 'Escape';
                    } else if (e.key.length === 1) {
                        capturedHotkey.key = e.key.toUpperCase();
                    } else {
                        capturedHotkey.key = e.key;
                    }

                    // Update display
                    input.value = formatHotkeyDisplay(capturedHotkey);

                    // Validate hotkey
                    validateHotkey(capturedHotkey);

                    // Remove listener
                    input.removeEventListener('keydown', handleKeyDown);
                }
            }

            input.addEventListener('keydown', handleKeyDown);
        }

        // Format hotkey for display
        function formatHotkeyDisplay(hk) {
            let result = '';
            if (hk.ctrl) result += '⌃';
            if (hk.shift) result += '⇧';
            if (hk.alt) result += '⌥';
            if (hk.cmd) result += '⌘';
            result += hk.key;
            return result;
        }

        // Validate hotkey for conflicts
        async function validateHotkey(hk) {
            try {
                const response = await fetch(`${API_BASE}/api/hotkey/validate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(hk)
                });

                if (!response.ok) {
                    throw new Error('Failed to validate hotkey');
                }

                const result = await response.json();
                const conflictDiv = document.getElementById('hotkey-modal-conflict');

                if (result.conflicts && result.conflicts.length > 0) {
                    document.getElementById('conflict-apps').textContent = result.conflicts.join(', ');
                    conflictDiv.style.display = 'block';
                } else {
                    conflictDiv.style.display = 'none';
                }
            } catch (error) {
                console.error('Failed to validate hotkey:', error);
            }
        }

        // Save hotkey
        async function saveHotkey() {
            if (!capturedHotkey.key) {
                alert('ホットキーを設定してください');
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/api/hotkey/register`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(capturedHotkey)
                });

                if (!response.ok) {
                    throw new Error('Failed to register hotkey');
                }

                const result = await response.json();

                // Update display
                document.getElementById('hotkey-display').value = formatHotkeyDisplay(capturedHotkey);

                closeHotkeyEditor();
                alert('ホットキーを変更しました: ' + formatHotkeyDisplay(capturedHotkey));
            } catch (error) {
                console.error('Failed to save hotkey:', error);
                alert('ホットキーの保存に失敗しました: ' + error.message);
            }
        }

        // Add input event listener for model path validation
        document.addEventListener('DOMContentLoaded', function() {
            console.log('EzS2T-Whisper settings page loaded');
            loadSettings();

            // Add debounced validation on model path input
            const modelPathInput = document.getElementById('model-path');
            let validationTimeout;
            modelPathInput.addEventListener('input', function(e) {
                clearTimeout(validationTimeout);
                validationTimeout = setTimeout(() => {
                    validateModelPath(e.target.value);
                }, 500);
            });
        });
    </script>
</body>
</html>

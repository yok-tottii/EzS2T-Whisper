<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EzS2T-Whisper è¨­å®š</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f7;
            color: #1d1d1f;
            line-height: 1.6;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        h1 {
            font-size: 32px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #6e6e73;
            margin-bottom: 40px;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .card h2 {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-weight: 500;
            margin-bottom: 8px;
        }

        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 14px;
        }

        button {
            background: #0071e3;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #0077ed;
        }

        .status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .status.granted {
            background: #d8f5e3;
            color: #0a7d3e;
        }

        .status.denied {
            background: #ffe5e5;
            color: #d70015;
        }

        .footer {
            text-align: center;
            margin-top: 40px;
            color: #6e6e73;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 data-i18n="page.heading">EzS2T-Whisper è¨­å®š</h1>
        <p class="subtitle" data-i18n="page.subtitle">éŸ³å£°æ–‡å­—èµ·ã“ã—ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®è¨­å®š</p>

        <div class="card">
            <h2 data-i18n="section.permissions">ã‚·ã‚¹ãƒ†ãƒ æ¨©é™</h2>
            <div class="form-group">
                <label data-i18n="label.microphone">ãƒã‚¤ã‚¯</label>
                <span class="status granted" id="mic-status">âœ“ <span data-i18n="label.granted">è¨±å¯æ¸ˆã¿</span></span>
            </div>
            <div class="form-group">
                <label data-i18n="label.accessibility">ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£</label>
                <span class="status granted" id="accessibility-status">âœ“ <span data-i18n="label.granted">è¨±å¯æ¸ˆã¿</span></span>
            </div>
        </div>

        <div class="card">
            <h2 data-i18n="section.hotkey">ãƒ›ãƒƒãƒˆã‚­ãƒ¼</h2>
            <div class="form-group">
                <label for="hotkey-display" data-i18n="label.hotkey_current">éŒ²éŸ³é–‹å§‹ã‚­ãƒ¼</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" id="hotkey-display" value="âŒƒâŒ¥â£" readonly style="flex: 1;">
                    <button type="button" onclick="openHotkeyEditor()" data-i18n="button.change">å¤‰æ›´...</button>
                </div>
                <div id="hotkey-conflict" style="margin-top: 8px; font-size: 12px; color: #d70015; display: none;"></div>
            </div>
            <div class="form-group">
                <label for="record-mode" data-i18n="label.record_mode">éŒ²éŸ³ãƒ¢ãƒ¼ãƒ‰</label>
                <select id="record-mode">
                    <option value="press-to-hold" data-i18n="option.press_to_hold">æŠ¼ä¸‹ä¸­éŒ²éŸ³</option>
                    <option value="toggle" data-i18n="option.toggle">ãƒˆã‚°ãƒ«åˆ‡æ›¿</option>
                </select>
            </div>
        </div>

        <!-- ãƒ›ãƒƒãƒˆã‚­ãƒ¼ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ« -->
        <div id="hotkey-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
            <div style="background: white; padding: 30px; border-radius: 12px; max-width: 500px; width: 90%;">
                <h3 data-i18n="modal.title">ãƒ›ãƒƒãƒˆã‚­ãƒ¼è¨­å®š</h3>
                <p style="color: #6e6e73; font-size: 14px; margin-bottom: 20px;" data-i18n="modal.instruction">
                    å…¥åŠ›æ¬„ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã€è¨­å®šã—ãŸã„ã‚­ãƒ¼ã®çµ„ã¿åˆã‚ã›ã‚’æŠ¼ã—ã¦ãã ã•ã„
                </p>

                <div style="margin-bottom: 20px;">
                    <input type="text" id="hotkey-input" placeholder="ã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„..." readonly
                           style="width: 100%; padding: 15px; font-size: 18px; text-align: center; cursor: pointer;"
                           onclick="captureHotkey()">
                </div>

                <div id="hotkey-modal-conflict" style="margin-bottom: 15px; padding: 10px; background: #ffe5e5; border-radius: 8px; display: none;">
                    <strong>âš ï¸ <span data-i18n="modal.conflict_warning">ç«¶åˆæ¤œå‡º:</span></strong> <span id="conflict-apps"></span>
                </div>

                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeHotkeyEditor()" style="background: #6e6e73;" data-i18n="modal.button_cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                    <button onclick="saveHotkey()" id="save-hotkey-btn" data-i18n="modal.button_save">ä¿å­˜</button>
                </div>
            </div>
        </div>

        <div class="card">
            <h2 data-i18n="section.recognition">éŸ³å£°èªè­˜</h2>
            <div class="form-group">
                <label for="model-path" data-i18n="label.model_path">ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" id="model-path" style="flex: 1;">
                    <button type="button" onclick="browseModelFile()" style="padding: 10px 20px;" data-i18n="button.browse">å‚ç…§...</button>
                </div>
                <div id="model-info" style="margin-top: 8px; font-size: 12px; color: #6e6e73;"></div>
                <div id="model-error" style="margin-top: 8px; font-size: 12px; color: #d70015; display: none;"></div>
            </div>
            <div style="padding: 12px; background: #f5f5f7; border-radius: 8px; font-size: 14px; color: #6e6e73;">
                <strong data-i18n="info.language_detection">ğŸŒ è¨€èªè‡ªå‹•æ¤œå‡º:</strong>
                <span data-i18n="info.language_description">Whisper.cppã«ã‚ˆã‚Šè©±è€…ã®å…¥åŠ›ã‹ã‚‰è‡ªå‹•çš„ã«è¨€èªã‚’åˆ¤æ–­ã—ã¾ã™ï¼ˆ100è¨€èªè¿‘ãã«å¯¾å¿œï¼‰</span>
            </div>
        </div>

        <div class="card">
            <h2 data-i18n="section.microphone">ãƒã‚¤ã‚¯è¨­å®š</h2>
            <div class="form-group">
                <label for="audio-device" data-i18n="label.audio_device">å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹</label>
                <select id="audio-device">
                    <option value="0" data-i18n="option.system_default">ã‚·ã‚¹ãƒ†ãƒ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ</option>
                </select>
            </div>
            <div class="form-group">
                <label for="ui-language" data-i18n="label.ui_language">UIè¨€èª</label>
                <select id="ui-language" onchange="setLanguage(this.value)">
                    <option value="ja">æ—¥æœ¬èª</option>
                    <option value="en">English</option>
                </select>
            </div>
        </div>

        <button onclick="saveSettings()" data-i18n="button.save">è¨­å®šã‚’ä¿å­˜</button>

        <div class="footer" data-i18n="footer">
            EzS2T-Whisper v0.3.0 | ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹ (MIT License)
        </div>
    </div>

    <script>
        // API base URL
        const API_BASE = '';

        // i18n translations
        const translations = {
            ja: {
                'page.title': 'EzS2T-Whisper è¨­å®š',
                'page.heading': 'EzS2T-Whisper è¨­å®š',
                'page.subtitle': 'éŸ³å£°æ–‡å­—èµ·ã“ã—ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®è¨­å®š',
                'section.permissions': 'ã‚·ã‚¹ãƒ†ãƒ æ¨©é™',
                'section.hotkey': 'ãƒ›ãƒƒãƒˆã‚­ãƒ¼',
                'section.recognition': 'éŸ³å£°èªè­˜',
                'section.microphone': 'ãƒã‚¤ã‚¯è¨­å®š',
                'label.microphone': 'ãƒã‚¤ã‚¯',
                'label.accessibility': 'ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£',
                'label.granted': 'è¨±å¯æ¸ˆã¿',
                'label.denied': 'æœªè¨±å¯',
                'label.hotkey_current': 'éŒ²éŸ³é–‹å§‹ã‚­ãƒ¼',
                'label.record_mode': 'éŒ²éŸ³ãƒ¢ãƒ¼ãƒ‰',
                'label.model_path': 'ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«',
                'label.audio_device': 'å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹',
                'label.ui_language': 'UIè¨€èª',
                'info.language_detection': 'ğŸŒ è¨€èªè‡ªå‹•æ¤œå‡º:',
                'info.language_description': 'Whisper.cppã«ã‚ˆã‚Šè©±è€…ã®å…¥åŠ›ã‹ã‚‰è‡ªå‹•çš„ã«è¨€èªã‚’åˆ¤æ–­ã—ã¾ã™ï¼ˆ100è¨€èªè¿‘ãã«å¯¾å¿œï¼‰',
                'button.change': 'å¤‰æ›´...',
                'button.browse': 'å‚ç…§...',
                'button.save': 'è¨­å®šã‚’ä¿å­˜',
                'placeholder.model_path': 'ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’é¸æŠã¾ãŸã¯å…¥åŠ›ã—ã¦ãã ã•ã„',
                'option.press_to_hold': 'æŠ¼ä¸‹ä¸­éŒ²éŸ³',
                'option.toggle': 'ãƒˆã‚°ãƒ«åˆ‡æ›¿',
                'option.system_default': 'ã‚·ã‚¹ãƒ†ãƒ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ',
                'alert.save_success': 'è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚\n\nSettings saved.\n\nå¤‰æ›´ã‚’é©ç”¨ã™ã‚‹ã«ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†èµ·å‹•ã—ã¦ãã ã•ã„ã€‚\nPlease restart the application to apply changes.',
                'alert.select_model': 'ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„',
                'alert.invalid_model': 'ç„¡åŠ¹ãªãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã§ã™',
                'alert.save_failed': 'è¨­å®šã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ',
                'alert.select_hotkey': 'ãƒ›ãƒƒãƒˆã‚­ãƒ¼ã‚’è¨­å®šã—ã¦ãã ã•ã„',
                'alert.modifier_key_recommended': 'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®ãŸã‚ã€å°‘ãªãã¨ã‚‚1ã¤ã®ä¿®é£¾ã‚­ãƒ¼ï¼ˆâŒƒâ‡§âŒ¥âŒ˜ï¼‰ã‚’è¨­å®šã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚',
                'modal.title': 'ãƒ›ãƒƒãƒˆã‚­ãƒ¼è¨­å®š',
                'modal.instruction': 'å…¥åŠ›æ¬„ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã€è¨­å®šã—ãŸã„ã‚­ãƒ¼ã®çµ„ã¿åˆã‚ã›ã‚’æŠ¼ã—ã¦ãã ã•ã„',
                'modal.conflict_warning': 'ç«¶åˆæ¤œå‡º:',
                'modal.button_save': 'ä¿å­˜',
                'modal.button_cancel': 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«',
                'footer': 'EzS2T-Whisper v0.3.0 | ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹ (MIT License)'
            },
            en: {
                'page.title': 'EzS2T-Whisper Settings',
                'page.heading': 'EzS2T-Whisper Settings',
                'page.subtitle': 'Speech-to-Text Application Settings',
                'section.permissions': 'System Permissions',
                'section.hotkey': 'Hotkey',
                'section.recognition': 'Speech Recognition',
                'section.microphone': 'Microphone Settings',
                'label.microphone': 'Microphone',
                'label.accessibility': 'Accessibility',
                'label.granted': 'Granted',
                'label.denied': 'Denied',
                'label.hotkey_current': 'Recording Hotkey',
                'label.record_mode': 'Recording Mode',
                'label.model_path': 'Model File',
                'label.audio_device': 'Input Device',
                'label.ui_language': 'UI Language',
                'info.language_detection': 'ğŸŒ Automatic Language Detection:',
                'info.language_description': 'Whisper.cpp automatically detects the language from speaker input (supports nearly 100 languages)',
                'button.change': 'Change...',
                'button.browse': 'Browse...',
                'button.save': 'Save Settings',
                'placeholder.model_path': 'Select or enter model file path',
                'option.press_to_hold': 'Press to Hold',
                'option.toggle': 'Toggle',
                'option.system_default': 'System Default',
                'alert.save_success': 'Settings saved.\n\nè¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚\n\nPlease restart the application to apply changes.\nå¤‰æ›´ã‚’é©ç”¨ã™ã‚‹ã«ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†èµ·å‹•ã—ã¦ãã ã•ã„ã€‚',
                'alert.select_model': 'Please select a model file',
                'alert.invalid_model': 'Invalid model file',
                'alert.save_failed': 'Failed to save settings',
                'alert.select_hotkey': 'Please set a hotkey',
                'alert.modifier_key_recommended': 'For security, it is recommended to set at least one modifier key (âŒƒâ‡§âŒ¥âŒ˜).',
                'modal.title': 'Set Hotkey',
                'modal.instruction': 'Click the input field and press your desired key combination',
                'modal.conflict_warning': 'Conflict Detected:',
                'modal.button_save': 'Save',
                'modal.button_cancel': 'Cancel',
                'footer': 'EzS2T-Whisper v0.3.0 | Open Source (MIT License)'
            }
        };

        // Current language
        let currentLanguage = 'ja';

        // Translation function
        function t(key) {
            return translations[currentLanguage]?.[key] || key;
        }

        // Set language and update UI
        function setLanguage(lang) {
            currentLanguage = lang;
            updateUILanguage();
        }

        // Update all UI text based on current language
        function updateUILanguage() {
            // Update all elements with data-i18n attribute
            document.querySelectorAll('[data-i18n]').forEach(elem => {
                const key = elem.getAttribute('data-i18n');
                const translation = t(key);

                if (elem.tagName === 'INPUT' && elem.type !== 'text') {
                    // For buttons, use value
                    elem.value = translation;
                } else {
                    // For other elements, use textContent
                    elem.textContent = translation;
                }
            });

            // Update page title
            document.title = t('page.title');

            // Update select options with data-i18n-options
            document.querySelectorAll('select').forEach(select => {
                select.querySelectorAll('option[data-i18n]').forEach(option => {
                    const key = option.getAttribute('data-i18n');
                    option.textContent = t(key);
                });
            });

            // Update placeholders
            const modelPathInput = document.getElementById('model-path');
            if (modelPathInput) {
                modelPathInput.placeholder = t('placeholder.model_path');
            }
        }

        // Load settings from server
        async function loadSettings() {
            try {
                const response = await fetch(`${API_BASE}/api/settings`);
                if (!response.ok) {
                    throw new Error('Failed to load settings');
                }
                const config = await response.json();

                // Set UI language first
                const uiLang = config.ui_language || 'ja';
                setLanguage(uiLang);
                const uiLangSelect = document.getElementById('ui-language');
                if (uiLangSelect) {
                    uiLangSelect.value = uiLang;
                }

                // Populate form fields
                document.getElementById('record-mode').value = config.recording_mode || 'press-to-hold';
                document.getElementById('model-path').value = config.model_path || '';

                // Display hotkey
                if (config.hotkey) {
                    document.getElementById('hotkey-display').value = formatHotkeyDisplay(config.hotkey);
                }

                // Load audio devices
                await loadAudioDevices(config.audio_device_id || -1);

                // Validate model path if present
                if (config.model_path) {
                    validateModelPath(config.model_path);
                }
            } catch (error) {
                console.error('Failed to load settings:', error);
            }
        }

        // Load audio devices
        async function loadAudioDevices(selectedDeviceId) {
            try {
                const response = await fetch(`${API_BASE}/api/devices`);
                if (!response.ok) {
                    throw new Error('Failed to load audio devices');
                }
                const result = await response.json();
                const devices = result.devices || [];

                // Sort devices: default device first, then others in original order
                devices.sort((a, b) => {
                    if (a.is_default && !b.is_default) return -1;
                    if (!a.is_default && b.is_default) return 1;
                    return 0;  // Keep original order for non-default devices
                });

                const select = document.getElementById('audio-device');
                select.innerHTML = ''; // Clear existing options

                // Add devices to dropdown
                devices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.id;
                    option.textContent = device.name + (device.is_default ? ' (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)' : '');
                    if (device.id === selectedDeviceId) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });

                // If no device was selected, select the default
                if (!select.value && devices.length > 0) {
                    const defaultDevice = devices.find(d => d.is_default);
                    if (defaultDevice) {
                        select.value = defaultDevice.id;
                    }
                }
            } catch (error) {
                console.error('Failed to load audio devices:', error);
                // Keep the default "ã‚·ã‚¹ãƒ†ãƒ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ" option
            }
        }

        // Browse for model file
        async function browseModelFile() {
            try {
                const response = await fetch(`${API_BASE}/api/models/browse`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to open file browser');
                }

                const result = await response.json();

                if (result.cancelled) {
                    return; // User cancelled
                }

                if (result.path) {
                    document.getElementById('model-path').value = result.path;

                    // Show model info
                    const infoDiv = document.getElementById('model-info');
                    infoDiv.textContent = `${result.name} (${result.size})`;
                    infoDiv.style.display = 'block';

                    // Hide error
                    document.getElementById('model-error').style.display = 'none';
                }
            } catch (error) {
                console.error('Failed to browse file:', error);
                const errorDiv = document.getElementById('model-error');
                errorDiv.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã‘ã¾ã›ã‚“ã§ã—ãŸ: ' + error.message;
                errorDiv.style.display = 'block';
            }
        }

        // Validate model path
        async function validateModelPath(path) {
            if (!path) {
                document.getElementById('model-info').style.display = 'none';
                document.getElementById('model-error').style.display = 'none';
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/api/models/validate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ path })
                });

                if (!response.ok) {
                    throw new Error('Failed to validate model path');
                }

                const result = await response.json();
                const infoDiv = document.getElementById('model-info');
                const errorDiv = document.getElementById('model-error');

                if (result.valid) {
                    infoDiv.textContent = `âœ“ ${result.name} (${result.size})`;
                    infoDiv.style.display = 'block';
                    infoDiv.style.color = '#0a7d3e';
                    errorDiv.style.display = 'none';
                } else {
                    infoDiv.style.display = 'none';
                    errorDiv.textContent = 'âœ— ' + result.message;
                    errorDiv.style.display = 'block';
                }
            } catch (error) {
                console.error('Failed to validate model path:', error);
                const errorDiv = document.getElementById('model-error');
                errorDiv.textContent = 'ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®æ¤œè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ';
                errorDiv.style.display = 'block';
            }
        }

        // Save settings
        async function saveSettings() {
            const modelPath = document.getElementById('model-path').value;
            const recordMode = document.getElementById('record-mode').value;
            const audioDeviceId = parseInt(document.getElementById('audio-device').value);
            const uiLanguage = document.getElementById('ui-language')?.value || 'ja';

            // Validate model path before saving
            if (!modelPath) {
                alert(t('alert.select_model'));
                return;
            }

            try {
                // Validate first
                const validateResponse = await fetch(`${API_BASE}/api/models/validate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ path: modelPath })
                });

                const validateResult = await validateResponse.json();
                if (!validateResult.valid) {
                    alert(t('alert.invalid_model') + ': ' + validateResult.message);
                    return;
                }

                // Save settings
                const response = await fetch(`${API_BASE}/api/settings`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model_path: modelPath,
                        recording_mode: recordMode,
                        language: 'auto',  // Always use automatic language detection
                        audio_device_id: audioDeviceId,
                        ui_language: uiLanguage
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to save settings');
                }

                alert(t('alert.save_success'));
            } catch (error) {
                console.error('Failed to save settings:', error);
                alert(t('alert.save_failed') + ': ' + error.message);
            }
        }

        // Hotkey management
        let capturedHotkey = {
            ctrl: false,
            shift: false,
            alt: false,
            cmd: false,
            key: ''
        };

        // Open hotkey editor modal
        function openHotkeyEditor() {
            document.getElementById('hotkey-modal').style.display = 'flex';
            document.getElementById('hotkey-input').value = '';
            document.getElementById('hotkey-modal-conflict').style.display = 'none';
            capturedHotkey = { ctrl: false, shift: false, alt: false, cmd: false, key: '' };
        }

        // Close hotkey editor modal
        function closeHotkeyEditor() {
            document.getElementById('hotkey-modal').style.display = 'none';
        }

        // Capture hotkey input
        function captureHotkey() {
            const input = document.getElementById('hotkey-input');
            input.focus();
            input.value = 'ã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„...';

            function handleKeyDown(e) {
                e.preventDefault();

                // Record modifier keys
                capturedHotkey.ctrl = e.ctrlKey;
                capturedHotkey.shift = e.shiftKey;
                capturedHotkey.alt = e.altKey;
                capturedHotkey.cmd = e.metaKey;

                // Record regular key
                if (e.key && !['Control', 'Shift', 'Alt', 'Meta'].includes(e.key)) {
                    // Convert key name
                    if (e.key === ' ') {
                        capturedHotkey.key = 'Space';
                    } else if (e.key === 'Enter') {
                        capturedHotkey.key = 'Return';
                    } else if (e.key === 'Esc' || e.key === 'Escape') {
                        capturedHotkey.key = 'Escape';
                    } else if (e.key.length === 1) {
                        capturedHotkey.key = e.key.toUpperCase();
                    } else {
                        capturedHotkey.key = e.key;
                    }

                    // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: ã‚­ãƒ£ãƒ—ãƒãƒ£ã•ã‚ŒãŸã‚­ãƒ¼æƒ…å ±ã‚’å‡ºåŠ›
                    console.log('Captured key:', e.key, 'â†’', capturedHotkey.key);
                    console.log('Full hotkey:', JSON.stringify(capturedHotkey));

                    // Update display
                    input.value = formatHotkeyDisplay(capturedHotkey);

                    // Validate hotkey
                    validateHotkey(capturedHotkey);

                    // Remove listener
                    input.removeEventListener('keydown', handleKeyDown);
                }
            }

            input.addEventListener('keydown', handleKeyDown);
        }

        // Format key name with special key symbols
        function formatKeyName(key) {
            const keySymbols = {
                'Space': 'â£',
                'Return': 'â',
                'Tab': 'â‡¥',
                'Escape': 'ESC'
            };
            return keySymbols[key] || key;
        }

        // Format hotkey for display
        function formatHotkeyDisplay(hk) {
            let result = '';
            if (hk.ctrl) result += 'âŒƒ';
            if (hk.shift) result += 'â‡§';
            if (hk.alt) result += 'âŒ¥';
            if (hk.cmd) result += 'âŒ˜';

            // é˜²å¾¡çš„å‡¦ç†: keyãŒç©ºã¾ãŸã¯undefinedã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨
            const keyName = hk.key || 'Space';
            result += formatKeyName(keyName);
            return result;
        }

        // Validate hotkey for conflicts
        async function validateHotkey(hk) {
            try {
                const response = await fetch(`${API_BASE}/api/hotkey/validate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(hk)
                });

                if (!response.ok) {
                    throw new Error('Failed to validate hotkey');
                }

                const result = await response.json();
                const conflictDiv = document.getElementById('hotkey-modal-conflict');

                if (result.conflicts && result.conflicts.length > 0) {
                    document.getElementById('conflict-apps').textContent = result.conflicts.join(', ');
                    conflictDiv.style.display = 'block';
                } else {
                    conflictDiv.style.display = 'none';
                }
            } catch (error) {
                console.error('Failed to validate hotkey:', error);
            }
        }

        // Save hotkey
        async function saveHotkey() {
            if (!capturedHotkey.key) {
                alert('ãƒ›ãƒƒãƒˆã‚­ãƒ¼ã‚’è¨­å®šã—ã¦ãã ã•ã„');
                return;
            }

            // Validate: at least one modifier should be set
            if (!capturedHotkey.ctrl && !capturedHotkey.shift && !capturedHotkey.alt && !capturedHotkey.cmd) {
                alert('ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®ãŸã‚ã€å°‘ãªãã¨ã‚‚1ã¤ã®ä¿®é£¾ã‚­ãƒ¼ï¼ˆâŒƒâ‡§âŒ¥âŒ˜ï¼‰ã‚’è¨­å®šã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚');
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/api/hotkey/register`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(capturedHotkey)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(errorText || 'Failed to register hotkey');
                }

                const result = await response.json();

                // Update display
                document.getElementById('hotkey-display').value = formatHotkeyDisplay(capturedHotkey);

                closeHotkeyEditor();

                // Check response status
                if (result.status === 'partial') {
                    alert('âš ï¸ ' + result.message);
                } else {
                    alert('âœ“ ãƒ›ãƒƒãƒˆã‚­ãƒ¼ã‚’å¤‰æ›´ã—ã¾ã—ãŸ: ' + formatHotkeyDisplay(capturedHotkey));
                }
            } catch (error) {
                console.error('Failed to save hotkey:', error);
                alert('âŒ ãƒ›ãƒƒãƒˆã‚­ãƒ¼ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ:\n' + error.message);
            }
        }

        // Add input event listener for model path validation
        document.addEventListener('DOMContentLoaded', function() {
            console.log('EzS2T-Whisper settings page loaded');
            loadSettings();

            // Add debounced validation on model path input
            const modelPathInput = document.getElementById('model-path');
            let validationTimeout;
            modelPathInput.addEventListener('input', function(e) {
                clearTimeout(validationTimeout);
                validationTimeout = setTimeout(() => {
                    validateModelPath(e.target.value);
                }, 500);
            });
        });
    </script>
</body>
</html>

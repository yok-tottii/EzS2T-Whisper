<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EzS2T-Whisper 設定</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f7;
            color: #1d1d1f;
            line-height: 1.6;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        h1 {
            font-size: 32px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #6e6e73;
            margin-bottom: 40px;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .card h2 {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-weight: 500;
            margin-bottom: 8px;
        }

        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 14px;
        }

        button {
            background: #0071e3;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #0077ed;
        }

        .status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .status.granted {
            background: #d8f5e3;
            color: #0a7d3e;
        }

        .status.denied {
            background: #ffe5e5;
            color: #d70015;
        }

        .footer {
            text-align: center;
            margin-top: 40px;
            color: #6e6e73;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 data-i18n="page.heading">EzS2T-Whisper 設定</h1>
        <p class="subtitle" data-i18n="page.subtitle">音声文字起こしアプリケーションの設定</p>

        <div class="card">
            <h2 data-i18n="section.permissions">システム権限</h2>
            <div class="form-group">
                <label data-i18n="label.microphone">マイク</label>
                <span class="status granted" id="mic-status">✓ <span data-i18n="label.granted">許可済み</span></span>
            </div>
            <div class="form-group">
                <label data-i18n="label.accessibility">アクセシビリティ</label>
                <span class="status granted" id="accessibility-status">✓ <span data-i18n="label.granted">許可済み</span></span>
            </div>
        </div>

        <div class="card">
            <h2 data-i18n="section.hotkey">ホットキー</h2>
            <div class="form-group">
                <label for="hotkey-display" data-i18n="label.hotkey_current">録音開始キー</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" id="hotkey-display" value="⌃⌥␣" readonly style="flex: 1;">
                    <button type="button" onclick="openHotkeyEditor()" data-i18n="button.change">変更...</button>
                </div>
                <div id="hotkey-conflict" style="margin-top: 8px; font-size: 12px; color: #d70015; display: none;"></div>
            </div>
            <div class="form-group">
                <label for="record-mode" data-i18n="label.record_mode">録音モード</label>
                <select id="record-mode">
                    <option value="press-to-hold" data-i18n="option.press_to_hold">押下中録音</option>
                    <option value="toggle" data-i18n="option.toggle">トグル切替</option>
                </select>
            </div>
        </div>

        <!-- ホットキー編集モーダル -->
        <div id="hotkey-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
            <div style="background: white; padding: 30px; border-radius: 12px; max-width: 500px; width: 90%;">
                <h3 data-i18n="modal.title">ホットキー設定</h3>
                <p style="color: #6e6e73; font-size: 14px; margin-bottom: 20px;" data-i18n="modal.instruction">
                    入力欄をクリックして、設定したいキーの組み合わせを押してください
                </p>

                <div style="margin-bottom: 20px;">
                    <input type="text" id="hotkey-input" placeholder="キーを押してください..." readonly
                           style="width: 100%; padding: 15px; font-size: 18px; text-align: center; cursor: pointer;"
                           onclick="captureHotkey()">
                </div>

                <div id="hotkey-modal-conflict" style="margin-bottom: 15px; padding: 10px; background: #ffe5e5; border-radius: 8px; display: none;">
                    <strong>⚠️ <span data-i18n="modal.conflict_warning">競合検出:</span></strong> <span id="conflict-apps"></span>
                </div>

                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeHotkeyEditor()" style="background: #6e6e73;" data-i18n="modal.button_cancel">キャンセル</button>
                    <button onclick="saveHotkey()" id="save-hotkey-btn" data-i18n="modal.button_save">保存</button>
                </div>
            </div>
        </div>

        <div class="card">
            <h2 data-i18n="section.recognition">音声認識</h2>
            <div class="form-group">
                <label for="model-path" data-i18n="label.model_path">モデルファイル</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" id="model-path" style="flex: 1;">
                    <button type="button" onclick="browseModelFile()" style="padding: 10px 20px;" data-i18n="button.browse">参照...</button>
                </div>
                <div id="model-info" style="margin-top: 8px; font-size: 12px; color: #6e6e73;"></div>
                <div id="model-error" style="margin-top: 8px; font-size: 12px; color: #d70015; display: none;"></div>
            </div>
            <div style="padding: 12px; background: #f5f5f7; border-radius: 8px; font-size: 14px; color: #6e6e73;">
                <strong data-i18n="info.language_detection">🌍 言語自動検出:</strong>
                <span data-i18n="info.language_description">Whisper.cppにより話者の入力から自動的に言語を判断します（100言語近くに対応）</span>
            </div>
        </div>

        <div class="card">
            <h2 data-i18n="section.microphone">マイク設定</h2>
            <div class="form-group">
                <label for="audio-device" data-i18n="label.audio_device">入力デバイス</label>
                <select id="audio-device">
                    <option value="0" data-i18n="option.system_default">システムデフォルト</option>
                </select>
            </div>
            <div class="form-group">
                <label for="ui-language" data-i18n="label.ui_language">UI言語</label>
                <select id="ui-language" onchange="setLanguage(this.value)">
                    <option value="ja">日本語</option>
                    <option value="en">English</option>
                </select>
            </div>
        </div>

        <button onclick="saveSettings()" data-i18n="button.save">設定を保存</button>

        <div class="footer" data-i18n="footer">
            EzS2T-Whisper v0.3.0 | オープンソース (MIT License)
        </div>
    </div>

    <script>
        // API base URL
        const API_BASE = '';

        // i18n translations
        const translations = {
            ja: {
                'page.title': 'EzS2T-Whisper 設定',
                'page.heading': 'EzS2T-Whisper 設定',
                'page.subtitle': '音声文字起こしアプリケーションの設定',
                'section.permissions': 'システム権限',
                'section.hotkey': 'ホットキー',
                'section.recognition': '音声認識',
                'section.microphone': 'マイク設定',
                'label.microphone': 'マイク',
                'label.accessibility': 'アクセシビリティ',
                'label.granted': '許可済み',
                'label.denied': '未許可',
                'label.hotkey_current': '録音開始キー',
                'label.record_mode': '録音モード',
                'label.model_path': 'モデルファイル',
                'label.audio_device': '入力デバイス',
                'label.ui_language': 'UI言語',
                'info.language_detection': '🌍 言語自動検出:',
                'info.language_description': 'Whisper.cppにより話者の入力から自動的に言語を判断します（100言語近くに対応）',
                'button.change': '変更...',
                'button.browse': '参照...',
                'button.save': '設定を保存',
                'placeholder.model_path': 'モデルファイルのパスを選択または入力してください',
                'option.press_to_hold': '押下中録音',
                'option.toggle': 'トグル切替',
                'option.system_default': 'システムデフォルト',
                'alert.save_success': '設定を保存しました。\n\nSettings saved.\n\n変更を適用するには、アプリケーションを再起動してください。\nPlease restart the application to apply changes.',
                'alert.select_model': 'モデルファイルを選択してください',
                'alert.invalid_model': '無効なモデルファイルです',
                'alert.save_failed': '設定の保存に失敗しました',
                'alert.select_hotkey': 'ホットキーを設定してください',
                'alert.modifier_key_recommended': 'セキュリティのため、少なくとも1つの修飾キー（⌃⇧⌥⌘）を設定することを推奨します。',
                'modal.title': 'ホットキー設定',
                'modal.instruction': '入力欄をクリックして、設定したいキーの組み合わせを押してください',
                'modal.conflict_warning': '競合検出:',
                'modal.button_save': '保存',
                'modal.button_cancel': 'キャンセル',
                'footer': 'EzS2T-Whisper v0.3.0 | オープンソース (MIT License)'
            },
            en: {
                'page.title': 'EzS2T-Whisper Settings',
                'page.heading': 'EzS2T-Whisper Settings',
                'page.subtitle': 'Speech-to-Text Application Settings',
                'section.permissions': 'System Permissions',
                'section.hotkey': 'Hotkey',
                'section.recognition': 'Speech Recognition',
                'section.microphone': 'Microphone Settings',
                'label.microphone': 'Microphone',
                'label.accessibility': 'Accessibility',
                'label.granted': 'Granted',
                'label.denied': 'Denied',
                'label.hotkey_current': 'Recording Hotkey',
                'label.record_mode': 'Recording Mode',
                'label.model_path': 'Model File',
                'label.audio_device': 'Input Device',
                'label.ui_language': 'UI Language',
                'info.language_detection': '🌍 Automatic Language Detection:',
                'info.language_description': 'Whisper.cpp automatically detects the language from speaker input (supports nearly 100 languages)',
                'button.change': 'Change...',
                'button.browse': 'Browse...',
                'button.save': 'Save Settings',
                'placeholder.model_path': 'Select or enter model file path',
                'option.press_to_hold': 'Press to Hold',
                'option.toggle': 'Toggle',
                'option.system_default': 'System Default',
                'alert.save_success': 'Settings saved.\n\n設定を保存しました。\n\nPlease restart the application to apply changes.\n変更を適用するには、アプリケーションを再起動してください。',
                'alert.select_model': 'Please select a model file',
                'alert.invalid_model': 'Invalid model file',
                'alert.save_failed': 'Failed to save settings',
                'alert.select_hotkey': 'Please set a hotkey',
                'alert.modifier_key_recommended': 'For security, it is recommended to set at least one modifier key (⌃⇧⌥⌘).',
                'modal.title': 'Set Hotkey',
                'modal.instruction': 'Click the input field and press your desired key combination',
                'modal.conflict_warning': 'Conflict Detected:',
                'modal.button_save': 'Save',
                'modal.button_cancel': 'Cancel',
                'footer': 'EzS2T-Whisper v0.3.0 | Open Source (MIT License)'
            }
        };

        // Current language
        let currentLanguage = 'ja';

        // Translation function
        function t(key) {
            return translations[currentLanguage]?.[key] || key;
        }

        // Set language and update UI
        function setLanguage(lang) {
            currentLanguage = lang;
            updateUILanguage();
        }

        // Update all UI text based on current language
        function updateUILanguage() {
            // Update all elements with data-i18n attribute
            document.querySelectorAll('[data-i18n]').forEach(elem => {
                const key = elem.getAttribute('data-i18n');
                const translation = t(key);

                if (elem.tagName === 'INPUT' && elem.type !== 'text') {
                    // For buttons, use value
                    elem.value = translation;
                } else {
                    // For other elements, use textContent
                    elem.textContent = translation;
                }
            });

            // Update page title
            document.title = t('page.title');

            // Update select options with data-i18n-options
            document.querySelectorAll('select').forEach(select => {
                select.querySelectorAll('option[data-i18n]').forEach(option => {
                    const key = option.getAttribute('data-i18n');
                    option.textContent = t(key);
                });
            });

            // Update placeholders
            const modelPathInput = document.getElementById('model-path');
            if (modelPathInput) {
                modelPathInput.placeholder = t('placeholder.model_path');
            }
        }

        // Load settings from server
        async function loadSettings() {
            try {
                const response = await fetch(`${API_BASE}/api/settings`);
                if (!response.ok) {
                    throw new Error('Failed to load settings');
                }
                const config = await response.json();

                // Set UI language first
                const uiLang = config.ui_language || 'ja';
                setLanguage(uiLang);
                const uiLangSelect = document.getElementById('ui-language');
                if (uiLangSelect) {
                    uiLangSelect.value = uiLang;
                }

                // Populate form fields
                document.getElementById('record-mode').value = config.recording_mode || 'press-to-hold';
                document.getElementById('model-path').value = config.model_path || '';

                // Display hotkey
                if (config.hotkey) {
                    document.getElementById('hotkey-display').value = formatHotkeyDisplay(config.hotkey);
                }

                // Load audio devices
                await loadAudioDevices(config.audio_device_id || -1);

                // Validate model path if present
                if (config.model_path) {
                    validateModelPath(config.model_path);
                }
            } catch (error) {
                console.error('Failed to load settings:', error);
            }
        }

        // Load audio devices
        async function loadAudioDevices(selectedDeviceId) {
            try {
                const response = await fetch(`${API_BASE}/api/devices`);
                if (!response.ok) {
                    throw new Error('Failed to load audio devices');
                }
                const result = await response.json();
                const devices = result.devices || [];

                // Sort devices: default device first, then others in original order
                devices.sort((a, b) => {
                    if (a.is_default && !b.is_default) return -1;
                    if (!a.is_default && b.is_default) return 1;
                    return 0;  // Keep original order for non-default devices
                });

                const select = document.getElementById('audio-device');
                select.innerHTML = ''; // Clear existing options

                // Add devices to dropdown
                devices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.id;
                    option.textContent = device.name + (device.is_default ? ' (デフォルト)' : '');
                    if (device.id === selectedDeviceId) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });

                // If no device was selected, select the default
                if (!select.value && devices.length > 0) {
                    const defaultDevice = devices.find(d => d.is_default);
                    if (defaultDevice) {
                        select.value = defaultDevice.id;
                    }
                }
            } catch (error) {
                console.error('Failed to load audio devices:', error);
                // Keep the default "システムデフォルト" option
            }
        }

        // Browse for model file
        async function browseModelFile() {
            try {
                const response = await fetch(`${API_BASE}/api/models/browse`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to open file browser');
                }

                const result = await response.json();

                if (result.cancelled) {
                    return; // User cancelled
                }

                if (result.path) {
                    document.getElementById('model-path').value = result.path;

                    // Show model info
                    const infoDiv = document.getElementById('model-info');
                    infoDiv.textContent = `${result.name} (${result.size})`;
                    infoDiv.style.display = 'block';

                    // Hide error
                    document.getElementById('model-error').style.display = 'none';
                }
            } catch (error) {
                console.error('Failed to browse file:', error);
                const errorDiv = document.getElementById('model-error');
                errorDiv.textContent = 'ファイル選択ダイアログを開けませんでした: ' + error.message;
                errorDiv.style.display = 'block';
            }
        }

        // Validate model path
        async function validateModelPath(path) {
            if (!path) {
                document.getElementById('model-info').style.display = 'none';
                document.getElementById('model-error').style.display = 'none';
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/api/models/validate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ path })
                });

                if (!response.ok) {
                    throw new Error('Failed to validate model path');
                }

                const result = await response.json();
                const infoDiv = document.getElementById('model-info');
                const errorDiv = document.getElementById('model-error');

                if (result.valid) {
                    infoDiv.textContent = `✓ ${result.name} (${result.size})`;
                    infoDiv.style.display = 'block';
                    infoDiv.style.color = '#0a7d3e';
                    errorDiv.style.display = 'none';
                } else {
                    infoDiv.style.display = 'none';
                    errorDiv.textContent = '✗ ' + result.message;
                    errorDiv.style.display = 'block';
                }
            } catch (error) {
                console.error('Failed to validate model path:', error);
                const errorDiv = document.getElementById('model-error');
                errorDiv.textContent = 'モデルファイルの検証に失敗しました';
                errorDiv.style.display = 'block';
            }
        }

        // Save settings
        async function saveSettings() {
            const modelPath = document.getElementById('model-path').value;
            const recordMode = document.getElementById('record-mode').value;
            const audioDeviceId = parseInt(document.getElementById('audio-device').value);
            const uiLanguage = document.getElementById('ui-language')?.value || 'ja';

            // Validate model path before saving
            if (!modelPath) {
                alert(t('alert.select_model'));
                return;
            }

            try {
                // Validate first
                const validateResponse = await fetch(`${API_BASE}/api/models/validate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ path: modelPath })
                });

                const validateResult = await validateResponse.json();
                if (!validateResult.valid) {
                    alert(t('alert.invalid_model') + ': ' + validateResult.message);
                    return;
                }

                // Save settings
                const response = await fetch(`${API_BASE}/api/settings`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model_path: modelPath,
                        recording_mode: recordMode,
                        language: 'auto',  // Always use automatic language detection
                        audio_device_id: audioDeviceId,
                        ui_language: uiLanguage
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to save settings');
                }

                alert(t('alert.save_success'));
            } catch (error) {
                console.error('Failed to save settings:', error);
                alert(t('alert.save_failed') + ': ' + error.message);
            }
        }

        // Hotkey management
        let capturedHotkey = {
            ctrl: false,
            shift: false,
            alt: false,
            cmd: false,
            key: ''
        };

        // Open hotkey editor modal
        function openHotkeyEditor() {
            document.getElementById('hotkey-modal').style.display = 'flex';
            document.getElementById('hotkey-input').value = '';
            document.getElementById('hotkey-modal-conflict').style.display = 'none';
            capturedHotkey = { ctrl: false, shift: false, alt: false, cmd: false, key: '' };
        }

        // Close hotkey editor modal
        function closeHotkeyEditor() {
            document.getElementById('hotkey-modal').style.display = 'none';
        }

        // Capture hotkey input
        function captureHotkey() {
            const input = document.getElementById('hotkey-input');
            input.focus();
            input.value = 'キーを押してください...';

            function handleKeyDown(e) {
                e.preventDefault();

                // Record modifier keys
                capturedHotkey.ctrl = e.ctrlKey;
                capturedHotkey.shift = e.shiftKey;
                capturedHotkey.alt = e.altKey;
                capturedHotkey.cmd = e.metaKey;

                // Record regular key
                if (e.key && !['Control', 'Shift', 'Alt', 'Meta'].includes(e.key)) {
                    // Convert key name
                    if (e.key === ' ') {
                        capturedHotkey.key = 'Space';
                    } else if (e.key === 'Enter') {
                        capturedHotkey.key = 'Return';
                    } else if (e.key === 'Esc' || e.key === 'Escape') {
                        capturedHotkey.key = 'Escape';
                    } else if (e.key.length === 1) {
                        capturedHotkey.key = e.key.toUpperCase();
                    } else {
                        capturedHotkey.key = e.key;
                    }

                    // デバッグログ: キャプチャされたキー情報を出力
                    console.log('Captured key:', e.key, '→', capturedHotkey.key);
                    console.log('Full hotkey:', JSON.stringify(capturedHotkey));

                    // Update display
                    input.value = formatHotkeyDisplay(capturedHotkey);

                    // Validate hotkey
                    validateHotkey(capturedHotkey);

                    // Remove listener
                    input.removeEventListener('keydown', handleKeyDown);
                }
            }

            input.addEventListener('keydown', handleKeyDown);
        }

        // Format key name with special key symbols
        function formatKeyName(key) {
            const keySymbols = {
                'Space': '␣',
                'Return': '⏎',
                'Tab': '⇥',
                'Escape': 'ESC'
            };
            return keySymbols[key] || key;
        }

        // Format hotkey for display
        function formatHotkeyDisplay(hk) {
            let result = '';
            if (hk.ctrl) result += '⌃';
            if (hk.shift) result += '⇧';
            if (hk.alt) result += '⌥';
            if (hk.cmd) result += '⌘';

            // 防御的処理: keyが空またはundefinedの場合はデフォルト値を使用
            const keyName = hk.key || 'Space';
            result += formatKeyName(keyName);
            return result;
        }

        // Validate hotkey for conflicts
        async function validateHotkey(hk) {
            try {
                const response = await fetch(`${API_BASE}/api/hotkey/validate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(hk)
                });

                if (!response.ok) {
                    throw new Error('Failed to validate hotkey');
                }

                const result = await response.json();
                const conflictDiv = document.getElementById('hotkey-modal-conflict');

                if (result.conflicts && result.conflicts.length > 0) {
                    document.getElementById('conflict-apps').textContent = result.conflicts.join(', ');
                    conflictDiv.style.display = 'block';
                } else {
                    conflictDiv.style.display = 'none';
                }
            } catch (error) {
                console.error('Failed to validate hotkey:', error);
            }
        }

        // Save hotkey
        async function saveHotkey() {
            if (!capturedHotkey.key) {
                alert('ホットキーを設定してください');
                return;
            }

            // Validate: at least one modifier should be set
            if (!capturedHotkey.ctrl && !capturedHotkey.shift && !capturedHotkey.alt && !capturedHotkey.cmd) {
                alert('セキュリティのため、少なくとも1つの修飾キー（⌃⇧⌥⌘）を設定することを推奨します。');
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/api/hotkey/register`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(capturedHotkey)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(errorText || 'Failed to register hotkey');
                }

                const result = await response.json();

                // Update display
                document.getElementById('hotkey-display').value = formatHotkeyDisplay(capturedHotkey);

                closeHotkeyEditor();

                // Check response status
                if (result.status === 'partial') {
                    alert('⚠️ ' + result.message);
                } else {
                    alert('✓ ホットキーを変更しました: ' + formatHotkeyDisplay(capturedHotkey));
                }
            } catch (error) {
                console.error('Failed to save hotkey:', error);
                alert('❌ ホットキーの保存に失敗しました:\n' + error.message);
            }
        }

        // Add input event listener for model path validation
        document.addEventListener('DOMContentLoaded', function() {
            console.log('EzS2T-Whisper settings page loaded');
            loadSettings();

            // Add debounced validation on model path input
            const modelPathInput = document.getElementById('model-path');
            let validationTimeout;
            modelPathInput.addEventListener('input', function(e) {
                clearTimeout(validationTimeout);
                validationTimeout = setTimeout(() => {
                    validateModelPath(e.target.value);
                }, 500);
            });
        });
    </script>
</body>
</html>
